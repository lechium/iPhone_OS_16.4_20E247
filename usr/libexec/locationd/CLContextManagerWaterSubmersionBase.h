//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

@class CLSubmersionDataCollector, CLTimer;

@interface CLContextManagerWaterSubmersionBase
{
    struct unique_ptr<CLPowerAssertion, std::default_delete<CLPowerAssertion>> _powerAssertionSubmersion;	// 40 = 0x28
    CLTimer *_submersionPowerAssertionTimer;	// 48 = 0x30
    struct unique_ptr<CLPowerAssertion, std::default_delete<CLPowerAssertion>> _powerAssertionHK;	// 56 = 0x38
    _Bool _updatingHK;	// 64 = 0x40
    _Bool _updatingSurfacePressure;	// 65 = 0x41
    long long _submersionState;	// 72 = 0x48
    long long _externalSubmersionState;	// 80 = 0x50
    CLSubmersionDataCollector *_hkCollector;	// 88 = 0x58
    double _deepThreshold;	// 96 = 0x60
    double _nearDepthLimitThreshold;	// 104 = 0x68
    double _pastMaxDepthThreshold;	// 112 = 0x70
    double _sensorErrorThreshold;	// 120 = 0x78
    double _lastHKUpdate;	// 128 = 0x80
    double _lastDefaultLevelLogTimestamp;	// 136 = 0x88
    shared_ptr_85043445 _aopSubmersionState;	// 144 = 0x90
}

- (id).cxx_construct;	// IMP=0x00200000004ce1ab
- (void).cxx_destruct;	// IMP=0x00100000004ce14a
@property double lastDefaultLevelLogTimestamp; // @synthesize lastDefaultLevelLogTimestamp=_lastDefaultLevelLogTimestamp;
@property double lastHKUpdate; // @synthesize lastHKUpdate=_lastHKUpdate;
@property double sensorErrorThreshold; // @synthesize sensorErrorThreshold=_sensorErrorThreshold;
@property double pastMaxDepthThreshold; // @synthesize pastMaxDepthThreshold=_pastMaxDepthThreshold;
@property double nearDepthLimitThreshold; // @synthesize nearDepthLimitThreshold=_nearDepthLimitThreshold;
@property double deepThreshold; // @synthesize deepThreshold=_deepThreshold;
@property CLSubmersionDataCollector *hkCollector; // @synthesize hkCollector=_hkCollector;
@property _Bool updatingSurfacePressure; // @synthesize updatingSurfacePressure=_updatingSurfacePressure;
@property shared_ptr_85043445 aopSubmersionState; // @synthesize aopSubmersionState=_aopSubmersionState;
@property long long externalSubmersionState; // @synthesize externalSubmersionState=_externalSubmersionState;
@property _Bool updatingHK; // @synthesize updatingHK=_updatingHK;
@property long long submersionState; // @synthesize submersionState=_submersionState;
- (void)notificationAcknowledged:(unsigned long long)arg1;	// IMP=0x00100000004cde46
- (void)startSubmersionPowerAssertion;	// IMP=0x00100000004cdcd5
- (void)retrieveCachedSubmersionState;	// IMP=0x00100000004cd9da
- (void)saveCachedSubmersionState:(shared_ptr_85043445)arg1;	// IMP=0x00100000004cd86a
- (void)onNotSubmerged;	// IMP=0x00100000004cd81e
- (void)onDeepSubmersion:(double)arg1 withStateChanged:(_Bool)arg2;	// IMP=0x00100000004cd7bb
- (void)onShallowSubmersion:(_Bool)arg1;	// IMP=0x00100000004cd76a
- (void)updateSubmersionStateFromMeasurement:(id)arg1;	// IMP=0x00100000004cd422
- (void)updateSubmersionStateFromAOPState:(shared_ptr_85043445)arg1;	// IMP=0x00100000004cd0c8
- (void)updateClientsSubmersionState:(id)arg1;	// IMP=0x00100000004ccf2d
- (void)updateClientsSubmersionMeasurement:(id)arg1;	// IMP=0x00100000004cc864
- (void)clientConnected:(id)arg1 withNotification:(unsigned long long)arg2;	// IMP=0x00100000004cc66c
- (void)notifyHKUpdates:(id)arg1;	// IMP=0x00100000004cc60e
- (void)stopHKCollector;	// IMP=0x00100000004cc4ea
- (void)startHKCollector:(double)arg1;	// IMP=0x00100000004cc36a
- (void)dealloc;	// IMP=0x00100000004cc280
- (id)initWithUniverse:(id)arg1 delegate:(id)arg2 withBuffer:(void *)arg3 withSourceAggregator:(id)arg4;	// IMP=0x00100000004cbde0

@end

